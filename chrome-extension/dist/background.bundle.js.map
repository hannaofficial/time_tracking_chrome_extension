{"version":3,"file":"background.bundle.js","mappings":";;;;AAEA;AAGA;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;;AAuBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","sources":["webpack://chrome-extension/./background.js"],"sourcesContent":["\n\nconsole.log(\"Background script of Browsing History Analyzer extension running!\");\n\n\nlet browsingHistoryData = null; // Global variable to store history data\n\n\nfunction getBrowsingHistory() {\n  const startTime = Date.now() - (7 * 24 * 60 * 60 * 1000); // Last 7 days (example)\n  chrome.history.search({\n      text: '', // Empty text to get all history\n      startTime: startTime,\n      maxResults: 4,\n  }, (historyItems) => {\n      if (chrome.runtime.lastError) {\n          console.error(\"Error fetching browsing history:\", chrome.runtime.lastError);\n          return; // Exit if history fetch fails\n      }\n      const historyToStore = historyItems;\n      chrome.storage.local.set({ browsingHistory: historyToStore }, () => {\n          if (chrome.runtime.lastError) {\n              console.error(\"Error saving history to local storage:\", chrome.runtime.lastError);\n          } else {\n              console.log(\"Browsing History (last 7 days) fetched and stored in local storage.\");\n          }\n      });\n  });\n}\n\nfunction loadHistoryFromStorage(callback) {\n  chrome.storage.local.get(['browsingHistory'], (result) => {\n      const storedHistory = result.browsingHistory;\n      if (storedHistory) {\n          console.log(\"Browsing history loaded from local storage.\");\n          callback(storedHistory); // Call callback with stored history\n      } else {\n          console.log(\"No browsing history found in local storage.\");\n          callback(null); // Call callback with null if no history\n      }\n  });\n}\n\n\n\nchrome.runtime.onStartup.addListener( () => { // Or use another event to trigger history fetch\n  console.log(\"Extension started or Chrome browser started!\");\n  loadHistoryFromStorage((storedHistory) => {\n    if (!storedHistory) {\n        getBrowsingHistory(); // Fetch and store if not in storage\n    }\n});\n\n  chrome.storage.local.get(['timeData'], (result) => {\n    if (!result.timeData){\n      chrome.storage.local.set({timeData: {}});\n    }\n  });\n});\n\n\n\n// Time tracking variables\nlet startTime = null;\nlet currentTabId = null;\nlet currentWindowId = null;\nlet currentDomain = null;\nlet currentURL = null;\nlet currentTitle = null;\nlet isWindowFocused = true;\nlet timeData = {};\nlet pageContentcache = {}\n\n// checking for existing time tracking data\nchrome.runtime.onInstalled.addListener( ()=>{\n\n  console.log(\"Extension installed or updated!\");\n  getBrowsingHistory(); // Fetch and store history on install/update\n  \n\n  chrome.storage.local.get(['timeData'], (result) => {\n    if (!result.timeData){\n      chrome.storage.local.set({timeData: {}});\n    }\n  })\n})\n\n// Tracking active tab\nfunction trackActivetab(tab){\n  if (!tab.url || tab.url.startsWith('chrome://')) return; // Ignore Chrome URLs  chrome url is for internal site like chrome://extensions\n\n  const domain = new URL(tab.url).hostname; // Extract domain from URL\n  const fullURL = tab.url;\n  const title = tab.title;\n  const now = Date.now();\n\n  if (currentURL && isWindowFocused && currentTabId) {\n    const duration = now - startTime;\n    const nowTime = new Date(now);\n    const formattedTime = nowTime.toLocaleString('en-IN', {\n                          timeZone: 'Asia/Kolkata',\n                          hour12: false, // Use 24-hour format \n                                                               })\n    console.log(`trackingTab Time spent on ${currentURL} (Title: ${currentTitle}): ${duration} ms saving at ${formattedTime}`); // Updated log message\n    saveTime(currentURL, currentTitle, duration); // Pass title to saveTime\n}\n  \n\n  currentDomain = domain;\n  currentURL = fullURL;\n  currentTitle = title;\n  startTime = now;\n  currentTabId = tab.id;\n  currentWindowId = tab.windowId;\n}\n\n// if there is change in tab\n// {\n//   id: 123,\n//   url: \"https://example.com\",\n//   title: \"Example Website\",\n//   active: true,\n//   ... // other properties\n// }\n\n\n\nchrome.tabs.onActivated.addListener((activeInfo) => {\n  console.log(\"Tab activated:\", activeInfo);\n  chrome.tabs.get(activeInfo.tabId, (tab) => {\n    console.log(\"Tab details:\", tab);\n    if (tab.url && !tab.url.startsWith('chrome://')) {\n      trackActivetab(tab);\n    }\n  });\n})\n\n// if tab is closed\nchrome.tabs.onRemoved.addListener((tabId, removeInfo) => {\n  console.log(\"Tab removed:\", tabId);\n  if(tabId === currentTabId) {\n    const endtime = Date.now();\n    const duration = endtime - startTime;\n    console.log(`Tab closed: ${currentURL} (Title: ${currentTitle}), Duration: ${duration} ms`);\n    saveTime(currentURL, currentTitle, duration);\n\n    // reset tracking variables\n    currentDomain = null;\n    currentURL = null;\n    currentTitle = null;\n    startTime = null;\n    currentTabId = null;\n  }\n})\n\n// if window is closed\n\nchrome.windows.onRemoved.addListener((closedwindowId)=>{\n\n  if (closedwindowId === currentWindowId) {\n  \n    const endtime = Date.now();\n    console.log(`Window closed: ${currentURL} (Title: ${currentTitle}), Duration: ${duration} ms`);\n    if (currentURL && isWindowFocused) {\n      const duration = endtime - startTime;\n      saveTime(currentURL, currentTitle, duration);\n    }\n\n    // Reset tracking\n    currentTabId = null;\n    currentDomain = null;\n    currentURL = null;\n    currentTitle = null;\n    startTime = null;\n    currentWindowId = null;\n  \n  }\n\n  \n\n})\n\n// if there is a change in URL in the active tab\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  console.log(\"Tab updated:\", changeInfo);\n  if (changeInfo.status === 'complete' && tab.active && !tab.url.startsWith('chrome://')) {\n    trackActivetab(tab)\n  }\n})\n\n// it see whether you are focused on the chrome window or others apps window\nchrome.windows.onFocusChanged.addListener((windowId) => {\n  const isWindowFocused = windowId !== chrome.windows.WINDOW_ID_NONE\n  if (isWindowFocused) {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n\n      if (tabs[0] && tabs[0].url && !tabs[0].url.startsWith('chrome://')) {\n        trackActivetab(tabs[0]);\n      }\n\n    })\n  }else if (currentURL){\n    const duration = Date.now() - startTime;\n    console.log('Window unfocused state')\n    saveTime(currentURL, currentTitle, duration);\n    currentDomain = null;\n    currentURL = null;\n    currentTitle = null;\n  }\n\n  \n})\n\n// save time to storage\n/** \n * Below code is actually to tell others coder what will the input of the below function would look like\n * @param {string} url The full URL visited.\n * @param {string} title The title of the page.\n * @param {number} duration The time spent in milliseconds.\n */\nfunction saveTime(url, title, duration) { // saveTimeFucntion\n  console.log(\"saveTime CALLED with:\", { url, title, duration });\n\n  if(!url || typeof url !== 'string' || typeof duration !== 'number' || isNaN(duration) || duration <= 0){\n\n    console.warn(\"saveTime: Invalid input provided.\", {url, title, duration});\n    return\n\n  }\n  \n let domain;\n try{\n  domain = new URL(url).hostname;\n  if (!domain){\n    if (parsedUrl.protocol === \"file:\") {\n      domain = \"local_files\"; // Group local files under a generic domain\n  } else {\n     console.warn(`saveTime: Could not extract a standard domain from URL \"${url}\". Using full URL as domain.`);\n     domain = url; // Fallback to using the full URL if domain extraction is tricky\n  }\n  }\n }catch(error){\n  console.error(`Savetime: Error parsing URL \"${url}\"`, error);\n  domain = \"invalid_urls\";\n  \n }\n\n const safeTitle = title || \"No Title\";\n\n //Implementing extracted content\n const contentFromCache = pageContentcache[url];\n const extractedTextForStorage = contentFromCache ? contentFromCache.text : null;\nconst textExtractionTimestamp = contentFromCache ? contentFromCache.timestamp : null;\n\n\n  chrome.storage.local.get(['timeData'], (result) => {\n\n   console.log(\"saveTime: Current timeData from storage:\", JSON.parse(JSON.stringify(result.timeData || {})));\n\n   let timeData = result.timeData || {};\n    if (!timeData[domain]) {\n      timeData[domain] = {\n          totalTime: 0,\n          items: [] // Store title, default to \"No Title\" if not available\n          };\n          console.log(`saveTime: Initialized new domain: ${domain}`);\n                        }\n    timeData[domain].totalTime += duration;\n    const items = timeData[domain].items;\n    /*\n     * One doubt here regarding array\n     * When I save array to items const the same array timeData[domain].items is copied\n     * Now if we change the items array then it will change the array inside timeData[domain] i.e. items inside it\n     * Really important concept\n    */\n    const itemIndex = items.findIndex(item => item.url === url);\n\n    let newUrlTotalTime;\n    if (itemIndex > -1){\n      items[itemIndex].time += duration;\n      items[itemIndex].title = safeTitle;\n\n      // extractedText\n      if(extractedTextForStorage){\n        items[itemIndex].extractedText = extractedTextForStorage;\n        items[itemIndex].textExtractedAt = textExtractionTimestamp;\n      }\n\n\n      newUrlTotalTime = items[itemIndex].time;\n    }else{\n      items.push({\n        title: safeTitle,\n        url: url,\n        time: duration,\n        extractedText: extractedTextForStorage,\n        textExtractedAt: textExtractionTimestamp\n      });\n      newUrlTotalTime = duration;\n    }\n\n    chrome.storage.local.set({ timeData: timeData }, () => {\n      // Check for runtime errors during set\n      if (chrome.runtime.lastError) {\n          console.error(\"saveTime: Error saving timeData to storage:\", chrome.runtime.lastError);\n      } else {\n          // Log details about the update\n          console.log(`Time saved for Domain: ${domain}`);\n          console.log(` -> URL: ${url} (Title: ${safeTitle})`);\n          console.log(`   -> Added: ${duration}ms`);\n          console.log(`   -> New URL Total: ${newUrlTotalTime}ms`);\n          console.log(`   -> Domain Total: ${timeData[domain].totalTime}ms`);\n          if(extractedTextForStorage){\n            console.log(` -> Extracted Text (first 50 chars): ${extractedTextForStorage.substring(0,50)}...`)\n          }\n          if (textExtractionTimestamp) {\n            console.log(`   -> Text Extracted At: ${new Date(textExtractionTimestamp).toLocaleString()}`);\n        }\n\n      }\n  });\n\n})\n}\n\n\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.message === \"get_time_data\") {\n      console.log(\"Received request for time data\");\n      chrome.storage.local.get(['timeData'], (result) => {\n          const timeData = result.timeData || {};\n          console.log(\"Time data sent:\", timeData);\n          sendResponse({ timeData: timeData });\n      });\n      return true;\n  }\n\n  if (request.message === \"request_history\") {\n      console.log(\"Received request for browsing history\");\n      loadHistoryFromStorage((storedHistory) => {\n          sendResponse({ history: storedHistory }); // Send history via callback we used promise/resolve async/await but it was showing error \n      });\n      return true;\n  }\n\n  if(request.type === \"PAGE_CONTENT_FOR_BACKGROUND\"){\n    if(request.url && request.extractedText){\n      console.log(`Background: Receive content for ${request.url.substring(0,100)}...`);\n      pageContentcache[request.url] = {\n        text: request.extractedText ?? \"\",\n        timestamp: Date.now()\n      }\n    }\n    return true\n  }\n// THis is the project of my life trying to build some product through this I will able to learn through you\n  // reset time data\n  if (request.message === \"reset_time_data\") {\n    console.log(\"Received request to reset time data\");\n    chrome.storage.local.set({ timeData: {} }, () => {\n        console.log(\"Time data reset in storage\");\n        sendResponse({ success: true }); // Send success response back to popup\n    });\n    return true; // Keep message channel open for async response\n}\n\n\n  return true;\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Weekly Reset Function (e.g., every Monday at 4:00 AM)\n// const resetWeekly = () => {\n//   const now = new Date();\n//   const nextReset = new Date(now);\n\n//   // Target day: 1 = Monday (0 = Sunday, 1 = Monday, ..., 6 = Saturday)\n//   const targetDay = 1;\n//   const targetHour = 4; // 4 AM\n//   const targetMinute = 0;\n\n//   // Move date forward until it hits the next Monday\n//   while (nextReset.getDay() !== targetDay || nextReset <= now) {\n//     nextReset.setDate(nextReset.getDate() + 1);\n//     nextReset.setHours(targetHour, targetMinute, 0, 0); // Set to 4:00 AM\n//   }\n\n//   chrome.alarms.create('weeklyReset', { when: nextReset.getTime() });\n// };\n\n// chrome.alarms.onAlarm.addListener((alarm) => {\n//   if (alarm.name === 'weeklyReset') {\n//     chrome.storage.local.set({ timeData: {} }, () => {\n//       console.log(\"Weekly timeData reset done ✅\");\n//     });\n//     resetWeekly(); // Schedule the next weekly reset\n//   }\n// });\n\n// // Call this once when the extension starts\n// resetWeekly();\n\n\n\n"],"names":[],"sourceRoot":""}